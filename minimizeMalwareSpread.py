# // Time Complexity :O(n^2) for matrix
# // Space Complexity :O(n) array and dfs
# // Did this code successfully run on Leetcode :Yes 
# // Any problem you faced while coding this : Line 41 issue no need to iterate


# // Your code here along with comments explaining your approach
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        colors = [-1] * n                       
        cl = 0

        for i in range(n):
            if colors[i] == -1:
                self.dfs(graph, colors, i, cl)
                cl +=1
        
        groups = [0]* cl
        for i in range(n):                              # count nodes in colors
            groups[colors[i]] += 1

        infected = [0]* cl                              # count infected   
        for n in initial:
            infected[colors[n]] += 1
        
        result = float('-inf')
        for n in initial:
            gr = colors[n]

            if infected[gr] == 1:
                if result == float('-inf'):
                    result = n
                elif groups[gr] > groups[colors[result]]:
                    result = n
                elif groups[gr] == groups[colors[result]]:
                    result =  min(result,n)
            

        if result == float('-inf'):
            result = min(initial)           # no need to iterate over initial and compare with n; min is O(1)

        return result

    def dfs(self, graph, colors, i, cl):
        #base case
        if colors[i] != -1: return      # if visited already, skip

        # logic
        colors[i] = cl                  # color no
        for j in range(len(graph)):
            if i == j: continue         # diagonal skip
            if graph[i][j] == 1 and colors[j] == -1:        # connected graph
                self.dfs(graph,colors,j,cl)

# // Time Complexity :O(n^2)
# // Space Complexity :O(n)
# // Did this code successfully run on Leetcode :No
# // Any problem you faced while coding this : Yes


# // Your code here along with comments explaining your approach

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        colors = [-1] * n
        cl = 0

        for i in range(n):
            if colors[i] == -1:
                self.dfs(graph, colors, i, cl)
            cl +=1
        
        groups = [0]* cl
        for i in range(n):                              # count nodes in colors
            groups[colors[i]] += 1

        infected = [0]* cl                              # count infected   
        for n in initial:
            infected[colors[n]] += 1
        
        result = float('-inf')                          # finding best node
        for n in initial:
            gr = colors[n]

            if infected[gr] == 1:
                if result == float('-inf'):
                    result = n
                elif groups[gr] > groups[colors[result]]:
                    result = n
                elif groups[gr] == groups[colors[result]]:
                    result =  min(result,n)
            

        if result == float('inf'):
            for n in initial:
                result = min(result,n)

        return result

    def dfs(self, graph, colors, i, cl):
        #base case
        if colors[i] != -1: return      # if visited already, skip

        # logic
        colors[i] = cl                  # color no
        for j in range(len(graph)):
            if i == j: continue         # diagonal skip
            if graph[i][j] == 1:        # connected graph
                self.dfs(graph,colors,j,cl)